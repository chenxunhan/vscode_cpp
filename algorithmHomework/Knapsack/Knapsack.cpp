#include <bits/stdc++.h>
using namespace std;
const int N = 20; //物品件数和背包负重的两者最大值

//n:物品件数, b:背包负重
//v[i]:第i件物品的价值, w[i]:第i件物品的质量
int n, b, v[N], w[N];
//F[k][y]:背包最大负重为y时将前k件物品装入背包可获得的最大价值,备忘录数组
//i[k][y]:获得最大价值F[k][y]时背包中存在的物品的最大标号
int F[N][N], i[N][N]; //F[n][b]就是最终答案,将所有物品装入背包可获得最大价值

/*初始化全局变量,将主函数中的物件的数目,各物件的价值,各物件的重量,
背包的最大负重赋值给对应的全局变量,方便上方函数使用*/
//当函数形参无需再函数内改变,加上const提高程序运行效率
void init(const int n_, const int b_, const int v_[], const int w_[]) {
    n = n_, b = b_;
    for (int i = 0; i < n; ++i)
        v[i + 1] = v_[i], w[i + 1] = w_[i];
}

//输出初始化信息:物件的数目,各物件的价值,各物件的重量,背包的最大负重
void print_mes() {
    printf("\n物件编号(n):");
    for (int i = 1; i <= n; ++i)
        printf("[%2d]", i);
    printf("\n    价值(v):");
    for (int i = 1; i <= n; ++i)
        printf("%4d", v[i]);
    cout << "\n    重量(w):";
    for (int i = 1; i <= n; ++i)
        printf("%4d", w[i]);
    printf("\n背包负重(b):%4d\n\n", b);
}

//利用初始化完成后的全局变量n, b, v[], w[]计算出F[][]和i[][]
void calculate_F_i() {
    for (int k = 1; k <= n; ++k) {
        F[k][0] = 0; //背包负重为0获得价值价值为0
        for (int y = 1; y <= b; ++y) {
            F[0][y] = 0;               //前0件物品装入背包获得价值为0
            F[1][y] = y / w[1] * v[1]; /*前1件物品装入背包获得的最大价值,
            即当前背包最大负重最多可以装入第1件物品的数目乘以第1件物品的价值*/

            /*第1条件(y >= w[k])说明:
            因为最大价值备忘录数组F[][]的行列下标不可取负数
            即为了防止 y<w[k] 时 F[k][y - w[k]]指针越界,就是不能F[k][负数]
            需要设置前提条件 y >= w[k],才能进入第2条件判断*/
            /*第2条件(F[k - 1][y] <= F[k][y - w[k]] + v[k])说明:
            如果选了1个第k件物品装入背包,发现获得最大价值比不装这第k件物品的价值大,装他!*/
            if ((y >= w[k]) && (F[k - 1][y] <= F[k][y - w[k]] + v[k])) {
                //背包原来负重为y,装了第k个物品,负重就变成 y - w[k],即 (当前背包负重-第k件物品的重量)
                F[k][y] = F[k][y - w[k]] + v[k]; /*将前k件物品装入负重y的背包获得的最大价值
                等于将 1个第k件物品的价值 和 前k件物品装入剩余负重的背包获得的最大价值 的和*/
                i[k][y] = k;                     /*将前k件物品装入负重y背包获最大价值时
                包中物品最大标号就等于k,因为第k件物品装下去了*/
                continue;                        //此处continue代替else,提高程序运行速度
            }
            /*若不满足y >= w[k],即当前背包负重y装不下第k件物品(y<w[k]) 
            或 如果选了1个第k件物品装入背包,发现获得最大价值还不如不装这第k件物品的价值大,那么*/
            F[k][y] = F[k - 1][y]; /*第k件物品 装不了 或 不装了,将前k件物品装入负重y的背包获得的最大价值
            等于将前 k-1 件物品装入负重y的背包获得的最大价值*/
            i[k][y] = i[k - 1][y]; /*将前k件物品装入负重y的背包获得最大价值时包中物品最大标号
            等于将前 k-1 件物品装入负重y的背包获得最大价值时包中物品最大标号,因为没有第k件物品*/
        }
    }
}

//输出获得的最大价值,备忘录数组F[][]
void print_F() {
    printf("价值函数:\n k\\y ");
    for (int y = 1; y <= b; ++y) {
        printf("[%2d]", y);
    }
    putchar('\n');
    for (int k = 1; k <= n; ++k) {
        printf("[%3d]", k);
        for (int y = 1; y <= b; ++y)
            printf("%3d ", F[k][y]);
        putchar('\n');
    }
    putchar('\n');
}

//输出获得最大价值时背包中存在的物品的最大标号数组i[][]
void print_i() {
    printf("标记函数:\n k\\y ");
    for (int y = 1; y <= b; ++y) {
        printf("[%2d]", y);
    }
    putchar('\n');
    for (int k = 1; k <= n; ++k) {
        printf("[%3d]", k);
        for (int y = 1; y <= b; ++y)
            printf("%3d ", i[k][y]);
        putchar('\n');
    }
    putchar('\n');
}

//递归输出装入计划
//按物品标号从小到大的顺序输出各物品对应装入数量,但是递归顺序是从大到小
//参数说明(当前输出的是第几件物品,当前背包重量,是否为主函数第一次调用)
//参数都有赋初值,若调用函数时不传参,则使用初值
void print_Plan(int k = n, int y = b, bool first = 1) {
    if (!k) { //等价于(k==0) 即递归到底条件 全部的物品的数目已经输出完毕
        printf("该实例的解为:");
        return;
    }
    int num = 0;                    //先置当前一层,第k件物品所需的数量为0
    while (i[k][y] == k)            //只要还需要放入第k件物品
        ++num, y -= w[k];           //第k件物品所需数量加1,并且减少相应的数量
    print_Plan(k - 1, y, 0);        //根据输出顺序,先输出第k-1个所需的数量
    printf("x%d=%d", k, num);       //上面已输出第k-1个所需的数量后再输出当前第k个所需的数量
    printf(first ? ".\n\n" : ", "); //如果输出不是在末端,输出',' ,否则输出'.'并换行
}

//输出最大价值
void print_res() {
    printf("最大价值为:%d\n\n", F[n][b]);
}

int main() {

    // //示例1
    // int n_ = 4, b_ = 10,
    //     v_[N] = {1, 3, 5, 9},
    //     w_[N] = {2, 3, 4, 7};

    // 示例2
    int n_ = 5, b_ = 15,
        v_[N] = {2, 4, 2, 1, 10},
        w_[N] = {2, 12, 1, 1, 4};
    //上面输入样例 v_[i]代表第(i+1)个物品的价值,w_[i]代表第(i+1)个物品的重量

    init(n_, b_, v_, w_); //初始化全局变量为用户定义变量
    print_mes();          //输出初始化信息
    calculate_F_i();      /*计算出最大价值备忘录数组F[][]和
                            获得最大价值时背包中存在的物品的最大标号数组i[][]*/
    print_F();            //输出获得的最大价值,备忘录数组F[][]
    print_i();            //输出获得最大价值时背包中存在的物品的最大标号数组i[][]
    print_Plan();         //输出装入计划
    print_res();          //输出最大价值
    return 0;
}